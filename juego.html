<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador Interactivo - Algoritmo Murci√©lago</title>
    <style>
        :root {
            --primary-gold: #ffd700;
            --primary-dark: #1a1a2e;
            --secondary-dark: #16213e;
            --accent-blue: #4834d4;
            --accent-light: #686de0;
            --success-green: #2ed573;
            --danger-red: #ff4757;
            --warning-orange: #ffa502;
            --text-light: #f5f6fa;
            --text-muted: #a4b0be;
            --shadow-gold: rgba(255, 215, 0, 0.3);
            --shadow-dark: rgba(0, 0, 0, 0.5);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, var(--primary-dark), var(--secondary-dark), #0f3460);
            font-family: 'Segoe UI', 'Roboto', 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: var(--text-light);
            overflow-x: hidden;
        }

        .game-container {
            position: relative;
            text-align: center;
            padding: 20px;
            max-width: 1200px;
            width: 100%;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }

        h1 {
            color: var(--primary-gold);
            text-shadow: 2px 2px 4px var(--shadow-dark);
            font-size: clamp(1.8rem, 4vw, 2.5rem);
            font-weight: 700;
            letter-spacing: -0.5px;
        }

        .game-stats {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }

        .stat-card {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), rgba(255, 215, 0, 0.05));
            border: 2px solid var(--primary-gold);
            border-radius: 12px;
            padding: 12px 18px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.2);
        }

        .stat-label {
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-bottom: 2px;
        }

        .stat-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--primary-gold);
        }

        .canvas-container {
            position: relative;
            display: inline-block;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 8px 32px var(--shadow-gold);
            background: rgba(0, 0, 0, 0.8);
        }

        canvas {
            display: block;
            border: 3px solid var(--primary-gold);
            background: linear-gradient(135deg, #0a0a0a, #1a1a1a);
            transition: all 0.3s ease;
        }

        canvas:hover {
            box-shadow: 0 0 30px var(--shadow-gold);
        }

        .game-instructions {
            margin-top: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            max-width: 1000px;
            margin-left: auto;
            margin-right: auto;
        }

        .instruction-card {
            background: linear-gradient(135deg, rgba(72, 52, 212, 0.1), rgba(104, 109, 224, 0.05));
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 12px;
            padding: 16px;
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
        }

        .instruction-card:hover {
            background: linear-gradient(135deg, rgba(72, 52, 212, 0.2), rgba(104, 109, 224, 0.1));
            border-color: rgba(255, 215, 0, 0.6);
            transform: translateY(-2px);
        }

        .instruction-icon {
            font-size: 1.5rem;
            margin-right: 8px;
        }

        .instruction-text {
            font-size: 0.9rem;
            line-height: 1.4;
            color: var(--text-muted);
        }

        /* Modal Styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background: linear-gradient(135deg, var(--secondary-dark), var(--accent-blue));
            padding: 30px;
            border-radius: 20px;
            border: 2px solid var(--primary-gold);
            max-width: 550px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.7);
            animation: slideIn 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .modal-content::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255, 215, 0, 0.1), transparent);
            animation: shimmer 3s infinite;
        }

        @keyframes slideIn {
            from { transform: translateY(-50px) scale(0.9); opacity: 0; }
            to { transform: translateY(0) scale(1); opacity: 1; }
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }
            100% { transform: translateX(100%) translateY(100%) rotate(45deg); }
        }

        .modal-header {
            color: var(--primary-gold);
            font-size: 1.6rem;
            margin-bottom: 20px;
            text-align: center;
            font-weight: 600;
            position: relative;
            z-index: 1;
        }

        .question-text {
            font-size: 1.1rem;
            margin-bottom: 25px;
            line-height: 1.5;
            text-align: left;
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 12px;
            border-left: 4px solid var(--primary-gold);
            position: relative;
            z-index: 1;
        }

        .answer-button {
            display: block;
            width: 100%;
            padding: 15px 20px;
            margin: 10px 0;
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-light));
            color: white;
            border: 2px solid transparent;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
            position: relative;
            z-index: 1;
            overflow: hidden;
        }

        .answer-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .answer-button:hover::before {
            left: 100%;
        }

        .answer-button:hover {
            background: linear-gradient(135deg, var(--accent-light), var(--accent-blue));
            border-color: var(--primary-gold);
            transform: translateX(5px);
            box-shadow: 0 5px 20px rgba(72, 52, 212, 0.4);
        }

        .feedback {
            margin-top: 20px;
            padding: 15px;
            border-radius: 12px;
            font-weight: 500;
            font-size: 1rem;
            text-align: left;
            line-height: 1.5;
            position: relative;
            z-index: 1;
            min-height: 60px;
            display: flex;
            align-items: center;
        }

        .feedback.correct {
            background: linear-gradient(135deg, rgba(46, 213, 115, 0.2), rgba(46, 213, 115, 0.1));
            border: 2px solid var(--success-green);
            color: var(--success-green);
        }

        .feedback.incorrect {
            background: linear-gradient(135deg, rgba(255, 71, 87, 0.2), rgba(255, 71, 87, 0.1));
            border: 2px solid var(--danger-red);
            color: var(--danger-red);
        }

        .victory-content {
            background: linear-gradient(135deg, var(--success-green), #54a0ff);
            text-align: center;
        }

        .victory-title {
            font-size: 3rem;
            color: var(--primary-gold);
            margin-bottom: 20px;
            text-shadow: 2px 2px 8px var(--shadow-dark);
            animation: bounce 2s infinite;
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
            60% { transform: translateY(-5px); }
        }

        .restart-button {
            padding: 15px 35px;
            background: linear-gradient(135deg, var(--primary-gold), var(--warning-orange));
            color: var(--primary-dark);
            border: none;
            border-radius: 25px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .restart-button:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 25px rgba(255, 215, 0, 0.5);
        }

        /* Mobile Controls */
        .mobile-controls {
            display: none;
            margin-top: 25px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            gap: 20px;
        }

        .control-info {
            background: linear-gradient(135deg, rgba(44, 44, 84, 0.8), rgba(64, 64, 122, 0.6));
            border: 2px solid var(--primary-gold);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            max-width: 400px;
            backdrop-filter: blur(10px);
        }

        .control-status {
            font-size: 1.1rem;
            margin-bottom: 15px;
            color: var(--primary-gold);
            font-weight: 600;
        }

        .enable-control-btn {
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-light));
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px;
        }

        .enable-control-btn:hover {
            background: linear-gradient(135deg, var(--accent-light), var(--accent-blue));
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(72, 52, 212, 0.4);
        }

        .control-instructions {
            font-size: 0.9rem;
            color: var(--text-muted);
            line-height: 1.5;
            margin-top: 15px;
        }

        .tilt-display {
            display: none;
            margin-top: 15px;
            padding: 12px;
            background: rgba(255, 215, 0, 0.1);
            border-radius: 8px;
            font-size: 0.9rem;
            font-family: 'Courier New', monospace;
        }

        .control-pad {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 8px;
            width: 200px;
            height: 200px;
        }

        .control-button {
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-light));
            border: 2px solid var(--primary-gold);
            border-radius: 15px;
            color: white;
            font-size: 1.8rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            position: relative;
            overflow: hidden;
        }

        .control-button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.3s ease, height 0.3s ease;
        }

        .control-button:active::before {
            width: 100%;
            height: 100%;
        }

        .control-button:active {
            background: linear-gradient(135deg, var(--accent-light), var(--accent-blue));
            transform: scale(0.95);
            box-shadow: inset 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .control-button.empty {
            background: transparent;
            border: none;
            cursor: default;
        }

        .control-button.empty:active {
            background: transparent;
            transform: none;
            box-shadow: none;
        }

        .control-center {
            background: linear-gradient(135deg, var(--secondary-dark), rgba(64, 64, 122, 0.8));
            border-color: var(--primary-gold);
            font-size: 1.5rem;
        }

        /* Progress Indicators */
        .progress-indicators {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .line-progress {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            background: rgba(255, 215, 0, 0.1);
            border-radius: 10px;
            min-width: 120px;
        }

        .line-label {
            font-size: 0.9rem;
            color: var(--primary-gold);
            margin-bottom: 5px;
            font-weight: 600;
        }

        .progress-dots {
            display: flex;
            gap: 5px;
        }

        .progress-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transition: all 0.3s ease;
        }

        .progress-dot.completed {
            background: var(--success-green);
            box-shadow: 0 0 10px rgba(46, 213, 115, 0.5);
        }

        /* Loading Animation */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--primary-dark);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.5s ease;
        }

        .loading-bat {
            font-size: 4rem;
            color: var(--primary-gold);
            animation: float 2s ease-in-out infinite;
            margin-bottom: 20px;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-20px); }
        }

        .loading-text {
            font-size: 1.2rem;
            color: var(--text-muted);
            text-align: center;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .game-container {
                padding: 15px;
            }

            .game-header {
                justify-content: center;
                text-align: center;
            }

            .game-stats {
                justify-content: center;
                width: 100%;
                margin-top: 10px;
            }

            canvas {
                max-width: 100%;
                height: auto;
            }

            .mobile-controls {
                display: flex;
            }

            .game-instructions {
                grid-template-columns: 1fr;
                margin-top: 15px;
            }

            .modal-content {
                margin: 20px;
                padding: 25px;
            }

            .victory-title {
                font-size: 2.5rem;
            }
        }

        @media (max-width: 480px) {
            .control-pad {
                width: 180px;
                height: 180px;
            }

            .control-button {
                font-size: 1.5rem;
            }

            .stat-card {
                padding: 10px 15px;
            }

            .stat-value {
                font-size: 1.1rem;
            }
        }

        /* Accessibility */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading-overlay">
        <div class="loading-bat">ü¶á</div>
        <div class="loading-text">
            <p>Cargando Simulador del Algoritmo Murci√©lago...</p>
            <p style="margin-top: 10px; font-size: 0.9rem;">Preparando entorno de aprendizaje interactivo</p>
        </div>
    </div>

    <div class="game-container" style="display: none;">
        <header class="game-header">
            <h1>ü¶á Simulador Algoritmo Murci√©lago</h1>
            <div class="game-stats">
                <div class="stat-card">
                    <div class="stat-label">Progreso</div>
                    <div class="stat-value" id="questionProgress">0/5</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Disponibles</div>
                    <div class="stat-value" id="availableQuestions">15/15</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Nivel</div>
                    <div class="stat-value" id="currentLevel">B√°sico</div>
                </div>
            </div>
        </header>

        <div class="canvas-container">
            <canvas id="gameCanvas" width="800" height="600" aria-label="√Årea de juego del algoritmo murci√©lago"></canvas>
        </div>

        <!-- Progress Indicators -->
        <div class="progress-indicators">
            <div class="line-progress">
                <div class="line-label">L√≠nea 1: Conceptos</div>
                <div class="progress-dots" id="line1Progress"></div>
            </div>
            <div class="line-progress">
                <div class="line-label">L√≠nea 2: Par√°metros</div>
                <div class="progress-dots" id="line2Progress"></div>
            </div>
            <div class="line-progress">
                <div class="line-label">L√≠nea 3: Aplicaciones</div>
                <div class="progress-dots" id="line3Progress"></div>
            </div>
        </div>
        <div class="mobile-controls" id="mobileControls">
        <div id="touchControlPad" class="control-pad" style="display: none;">
                <div class="control-button empty"></div>
                <div class="control-button" data-direction="up" aria-label="Mover arriba">‚Üë</div>
                <div class="control-button empty"></div>
                <div class="control-button" data-direction="left" aria-label="Mover izquierda">‚Üê</div>
                <div class="control-button control-center" aria-label="Centro de control">ü¶á</div>
                <div class="control-button" data-direction="right" aria-label="Mover derecha">‚Üí</div>
                <div class="control-button empty"></div>
                <div class="control-button" data-direction="down" aria-label="Mover abajo">‚Üì</div>
                <div class="control-button empty"></div>
            </div>
            <button id="toggleControlMode" class="enable-control-btn" style="display: none;">
                Cambiar Modo de Control
            </button>
            </div>

        <div class="game-instructions">
            <div class="instruction-card">
                <div class="instruction-icon">üñ•Ô∏è</div>
                <div class="instruction-text">
                    <strong>Controles PC:</strong> Utiliza las teclas de direcci√≥n (‚Üë‚Üì‚Üê‚Üí) para navegar por el laberinto
                </div>
            </div>
            <div class="instruction-card">
                <div class="instruction-icon">üì±</div>
                <div class="instruction-text">
                    <strong>Controles M√≥vil:</strong> Inclina tu dispositivo o usa los controles t√°ctiles para moverte
                </div>
            </div>
            <div class="instruction-card">
                <div class="instruction-icon">üéØ</div>
                <div class="instruction-text">
                    <strong>Objetivo:</strong> Responde 5 preguntas correctamente y llega a la salida para completar el desaf√≠o
                </div>
            </div>
            <div class="instruction-card">
                <div class="instruction-icon">üî¥</div>
                <div class="instruction-text">
                    <strong>Preguntas:</strong> Toca los c√≠rculos rojos para acceder a preguntas sobre el algoritmo murci√©lago
                </div>
            </div>
        </div>

        <!-- Mobile Controls -->
        <div class="mobile-controls" id="mobileControls">
            <div class="control-info">
                <div id="controlStatus" class="control-status">üéÆ Controles de Movimiento</div>
                <button id="enableMotionBtn" class="enable-control-btn" style="display: none;">
                    Activar Sensores de Movimiento
                </button>
                <div class="control-instructions">
                    <p><strong>üì± Controles por Inclinaci√≥n:</strong></p>
                    <p>‚Ä¢ Inclina izquierda/derecha para movimiento horizontal</p>
                    <p>‚Ä¢ Inclina adelante/atr√°s para movimiento vertical</p>
                    <p>‚Ä¢ El murci√©lago seguir√° la inclinaci√≥n de tu dispositivo</p>
                </div>
                <div id="tiltDisplay" class="tilt-display">
                    Inclinaci√≥n: X: <span id="tiltX">0</span>¬∞ | Y: <span id="tiltY">0</span>¬∞
                </div>
            </div>
            
            
            
        </div>
    </div>

    <!-- Question Modal -->
    <div id="questionModal" class="modal" role="dialog" aria-labelledby="modalTitle" aria-describedby="modalDescription">
        <div class="modal-content">
            <h2 id="modalTitle" class="modal-header">Pregunta sobre Algoritmo Murci√©lago</h2>
            <p id="questionText" class="question-text"></p>
            <div id="answerContainer" role="radiogroup" aria-labelledby="modalTitle"></div>
            <div id="feedback" class="feedback" aria-live="polite"></div>
        </div>
    </div>

    <!-- Victory Modal -->
    <div id="victoryModal" class="modal">
        <div class="modal-content victory-content">
            <h2 class="victory-title">¬°üéâ SIMULACI√ìN COMPLETADA! üéâ</h2>
            <p style="font-size: 1.2rem; margin-bottom: 15px;">¬°Excelente trabajo!</p>
            <p style="margin-bottom: 20px;">Has demostrado un s√≥lido entendimiento del Algoritmo Murci√©lago y sus aplicaciones en optimizaci√≥n.</p>
            <div style="margin: 20px 0; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 10px;">
                <p><strong>üß† Conceptos Dominados:</strong></p>
                <p>‚úÖ Eco-localizaci√≥n y metaheur√≠stica</p>
                <p>‚úÖ Par√°metros del algoritmo</p>
                <p>‚úÖ Aplicaciones pr√°cticas</p>
            </div>
            <button class="restart-button" onclick="gameController.restartGame()" aria-label="Reiniciar simulaci√≥n">
                Nueva Simulaci√≥n
            </button>
        </div>
    </div>

    <script>
        // Game Controller - Main Game Logic
        class GameController {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                // Game constants
                this.CELL_SIZE = 40;
                this.COLS = Math.floor(this.canvas.width / this.CELL_SIZE);
                this.ROWS = Math.floor(this.canvas.height / this.CELL_SIZE);
                
                // Game state
                this.gameState = {
                    bat: {
                        x: 60,
                        y: 60,
                        size: 15,
                        speed: 3
                    },
                    echoWaves: [],
                    questions: [],
                    answeredQuestions: 0,
                    totalQuestions: 15,
                    requiredQuestions: 5,
                    currentQuestion: null,
                    gameWon: false,
                    level: 'B√°sico'
                };

                // Maze layout - optimized for better performance
                this.maze = [
                    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
                ];

                // Question bank - enhanced with better explanations
                this.questionBank = [
                    // L√≠nea 1 - Conceptos b√°sicos
                    {
                        question: "¬øQu√© es la eco-localizaci√≥n en el contexto del algoritmo murci√©lago?",
                        answers: [
                            "Un m√©todo para enviar emails",
                            "Un sistema de navegaci√≥n basado en ondas sonoras",
                            "Un tipo de base de datos",
                            "Un protocolo de red"
                        ],
                        correct: 1,
                        explanation: "La eco-localizaci√≥n es el sistema natural que usan los murci√©lagos para navegar emitiendo ondas sonoras y analizando los ecos que regresan, inspirando este algoritmo de optimizaci√≥n."
                    },
                    {
                        question: "¬øQu√© tipo de algoritmo es el algoritmo murci√©lago?",
                        answers: [
                            "Algoritmo de ordenamiento",
                            "Algoritmo de b√∫squeda lineal",
                            "Algoritmo de optimizaci√≥n metaheur√≠stica",
                            "Algoritmo de encriptaci√≥n"
                        ],
                        correct: 2,
                        explanation: "Es una metaheur√≠stica de optimizaci√≥n que simula el comportamiento de eco-localizaci√≥n de los murci√©lagos para encontrar soluciones √≥ptimas en problemas complejos."
                    },
                    {
                        question: "¬øEn qu√© a√±o fue propuesto el algoritmo murci√©lago?",
                        answers: [
                            "2008",
                            "2010",
                            "2012",
                            "2015"
                        ],
                        correct: 1,
                        explanation: "El algoritmo murci√©lago fue desarrollado por Xin-She Yang en 2010, bas√°ndose en estudios del comportamiento natural de estos mam√≠feros voladores."
                    },
                    {
                        question: "¬øCu√°l es la principal inspiraci√≥n del algoritmo murci√©lago?",
                        answers: [
                            "El vuelo de las aves",
                            "La eco-localizaci√≥n de los murci√©lagos",
                            "El comportamiento de las hormigas",
                            "La reproducci√≥n de las abejas"
                        ],
                        correct: 1,
                        explanation: "Se basa espec√≠ficamente en la eco-localizaci√≥n que usan los murci√©lagos para cazar y navegar en completa oscuridad, usando ondas ultras√≥nicas."
                    },
                    {
                        question: "¬øCu√°ntos par√°metros principales controlan el algoritmo murci√©lago?",
                        answers: [
                            "2 par√°metros",
                            "3 par√°metros",
                            "4 par√°metros",
                            "5 par√°metros"
                        ],
                        correct: 1,
                        explanation: "Los tres par√°metros fundamentales son: frecuencia (f), volumen (A) y tasa de pulsos (r), que controlan la exploraci√≥n y explotaci√≥n del espacio de b√∫squeda."
                    },

                    // L√≠nea 2 - Par√°metros y funcionamiento
                    {
                        question: "¬øCu√°les son los tres par√°metros principales del algoritmo murci√©lago?",
                        answers: [
                            "Velocidad, direcci√≥n y color",
                            "Frecuencia, volumen y tasa de pulsos",
                            "Altura, peso y edad",
                            "TCP, UDP y HTTP"
                        ],
                        correct: 1,
                        explanation: "Los par√°metros clave son: frecuencia (f) para exploraci√≥n, volumen (A) para intensidad de b√∫squeda, y tasa de pulsos (r) para frecuencia de emisi√≥n."
                    },
                    {
                        question: "¬øQu√© sucede con el volumen cuando el murci√©lago se acerca a una soluci√≥n √≥ptima?",
                        answers: [
                            "Aumenta exponencialmente",
                            "Se mantiene constante",
                            "Disminuye gradualmente",
                            "Se hace cero inmediatamente"
                        ],
                        correct: 2,
                        explanation: "El volumen disminuye conforme el murci√©lago se acerca a una buena soluci√≥n, representando mayor precisi√≥n en la b√∫squeda local."
                    },
                    {
                        question: "¬øC√≥mo var√≠a la frecuencia en el algoritmo murci√©lago?",
                        answers: [
                            "Se mantiene constante",
                            "Var√≠a aleatoriamente entre fmin y fmax",
                            "Siempre es cero",
                            "Depende del color del murci√©lago"
                        ],
                        correct: 1,
                        explanation: "La frecuencia var√≠a uniformemente entre valores m√≠nimo y m√°ximo para explorar diferentes regiones del espacio de soluciones de manera eficiente."
                    },
                    {
                        question: "¬øQu√© representa la tasa de pulsos en el algoritmo?",
                        answers: [
                            "La velocidad de vuelo",
                            "La frecuencia de emisi√≥n de pulsos sonoros",
                            "El tama√±o del murci√©lago",
                            "La temperatura del ambiente"
                        ],
                        correct: 1,
                        explanation: "La tasa de pulsos controla qu√© tan frecuentemente el murci√©lago emite ondas sonoras, afectando la intensidad de la b√∫squeda local."
                    },
                    {
                        question: "¬øCu√°l es el prop√≥sito de la b√∫squeda local en el algoritmo murci√©lago?",
                        answers: [
                            "Generar nuevos murci√©lagos",
                            "Eliminar murci√©lagos d√©biles",
                            "Intensificar la b√∫squeda alrededor de buenas soluciones",
                            "Cambiar el color de los murci√©lagos"
                        ],
                        correct: 2,
                        explanation: "La b√∫squeda local permite exploraci√≥n detallada alrededor de las mejores soluciones encontradas, mejorando la calidad de los resultados."
                    },

                    // L√≠nea 3 - Aplicaciones y optimizaci√≥n
                    {
                        question: "¬øCu√°l es el objetivo principal del algoritmo murci√©lago?",
                        answers: [
                            "Simular el vuelo de murci√©lagos reales",
                            "Encontrar soluciones √≥ptimas en problemas de optimizaci√≥n",
                            "Crear videojuegos",
                            "Procesar im√°genes"
                        ],
                        correct: 1,
                        explanation: "Su objetivo es encontrar la mejor soluci√≥n posible en espacios de b√∫squeda complejos, resolviendo problemas de optimizaci√≥n de manera eficiente."
                    },
                    {
                        question: "¬øQu√© representa cada murci√©lago en el algoritmo?",
                        answers: [
                            "Un error en el c√≥digo",
                            "Una soluci√≥n candidata",
                            "Un obst√°culo",
                            "Un punto de referencia"
                        ],
                        correct: 1,
                        explanation: "Cada murci√©lago representa una posible soluci√≥n al problema de optimizaci√≥n, movi√©ndose por el espacio de b√∫squeda para encontrar mejores alternativas."
                    },
                    {
                        question: "¬øEn qu√© tipos de problemas se aplica el algoritmo murci√©lago?",
                        answers: [
                            "Solo problemas de ordenamiento",
                            "Optimizaci√≥n continua, discreta y multiobjetivo",
                            "Solo problemas de bases de datos",
                            "Problemas de dise√±o gr√°fico √∫nicamente"
                        ],
                        correct: 1,
                        explanation: "Es vers√°til y se aplica en optimizaci√≥n continua, discreta, multiobjetivo, problemas de ingenier√≠a, finanzas, y muchas otras √°reas."
                    },
                    {
                        question: "¬øQu√© ventaja principal tiene el algoritmo murci√©lago?",
                        answers: [
                            "Es m√°s lento pero preciso",
                            "Equilibra exploraci√≥n y explotaci√≥n autom√°ticamente",
                            "Solo funciona con n√∫meros enteros",
                            "Requiere muchos par√°metros complejos"
                        ],
                        correct: 1,
                        explanation: "Su fortaleza es el balance autom√°tico entre exploraci√≥n global (buscar nuevas √°reas) y explotaci√≥n local (refinar soluciones buenas)."
                    },
                    {
                        question: "¬øC√≥mo se actualiza la posici√≥n de un murci√©lago en el algoritmo?",
                        answers: [
                            "Solo de manera aleatoria",
                            "Bas√°ndose en velocidad calculada por frecuencia y mejores soluciones",
                            "Siguiendo una l√≠nea recta siempre",
                            "La posici√≥n nunca se actualiza"
                        ],
                        correct: 1,
                        explanation: "La posici√≥n se actualiza usando velocidad calculada a partir de la frecuencia y las mejores soluciones encontradas, simulando el movimiento dirigido."
                    }
                ];

                // Controllers
                this.inputController = new InputController(this);
                this.renderController = new RenderController(this);
                this.uiController = new UIController(this);
                
                this.init();
            }

            init() {
                this.initializeQuestions();
                this.setupEventListeners();
                this.updateUI();
                this.startGameLoop();
                this.showLoadingScreen();
            }

            showLoadingScreen() {
                const loadingScreen = document.getElementById('loadingScreen');
                const gameContainer = document.querySelector('.game-container');
                
                setTimeout(() => {
                    loadingScreen.style.opacity = '0';
                    setTimeout(() => {
                        loadingScreen.style.display = 'none';
                        gameContainer.style.display = 'block';
                    }, 500);
                }, 2000);
            }

            initializeQuestions() {
                this.gameState.questions = [];
                
                // Line 1 (row 1)
                for (let i = 0; i < 5; i++) {
                    const x = 2 + i * 3;
                    this.gameState.questions.push({
                        x: x * this.CELL_SIZE + this.CELL_SIZE/2,
                        y: 1 * this.CELL_SIZE + this.CELL_SIZE/2,
                        answered: false,
                        questionData: this.questionBank[i],
                        line: 1
                    });
                }
                
                // Line 2 (row 5)
                for (let i = 0; i < 5; i++) {
                    const x = 2 + i * 3;
                    this.gameState.questions.push({
                        x: x * this.CELL_SIZE + this.CELL_SIZE/2,
                        y: 5 * this.CELL_SIZE + this.CELL_SIZE/2,
                        answered: false,
                        questionData: this.questionBank[5 + i],
                        line: 2
                    });
                }
                
                // Line 3 (row 9)
                for (let i = 0; i < 5; i++) {
                    const x = 2 + i * 3;
                    this.gameState.questions.push({
                        x: x * this.CELL_SIZE + this.CELL_SIZE/2,
                        y: 9 * this.CELL_SIZE + this.CELL_SIZE/2,
                        answered: false,
                        questionData: this.questionBank[10 + i],
                        line: 3
                    });
                }

                // Exit position
                this.gameState.exit = {
                    x: (this.COLS - 2) * this.CELL_SIZE + this.CELL_SIZE/2,
                    y: (this.ROWS - 2) * this.CELL_SIZE + this.CELL_SIZE/2
                };
            }

            setupEventListeners() {
                // Keyboard events
                document.addEventListener('keydown', (e) => this.inputController.handleKeyDown(e));
                document.addEventListener('keyup', (e) => this.inputController.handleKeyUp(e));
                
                // Prevent arrow key scrolling
                document.addEventListener('keydown', (e) => {
                    if(['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                        e.preventDefault();
                    }
                });
            }

            updateGame() {
                if (this.gameState.gameWon) return;

                const bat = this.gameState.bat;
                const prevX = bat.x;
                const prevY = bat.y;

                // Apply movement from input controller
                this.inputController.updateMovement();

                // Create echo waves when moving
                if (bat.x !== prevX || bat.y !== prevY) {
                    if (Math.random() < 0.3) {
                        this.createEchoWave();
                    }
                }

                // Update echo waves
                this.updateEchoWaves();

                // Check collisions
                this.checkQuestionCollisions();
                this.checkExitCollision();
            }

            createEchoWave() {
                this.gameState.echoWaves.push({
                    x: this.gameState.bat.x,
                    y: this.gameState.bat.y,
                    radius: 0,
                    maxRadius: 60,
                    opacity: 1
                });
            }

            updateEchoWaves() {
                this.gameState.echoWaves = this.gameState.echoWaves.filter(wave => {
                    wave.radius += 3;
                    wave.opacity = 1 - (wave.radius / wave.maxRadius);
                    return wave.radius <= wave.maxRadius;
                });
            }

            canMoveTo(x, y) {
                const gridX = Math.floor(x / this.CELL_SIZE);
                const gridY = Math.floor(y / this.CELL_SIZE);
                
                if (gridX < 0 || gridX >= this.COLS || gridY < 0 || gridY >= this.ROWS) {
                    return false;
                }
                
                return !this.maze[gridY] || this.maze[gridY][gridX] === 0;
            }

            checkQuestionCollisions() {
                this.gameState.questions.forEach(q => {
                    if (!q.answered) {
                        const dx = this.gameState.bat.x - q.x;
                        const dy = this.gameState.bat.y - q.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < 25) {
                            this.uiController.showQuestion(q);
                        }
                    }
                });
            }

            checkExitCollision() {
                if (this.gameState.answeredQuestions >= this.gameState.requiredQuestions) {
                    const dx = this.gameState.bat.x - this.gameState.exit.x;
                    const dy = this.gameState.bat.y - this.gameState.exit.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 35) {
                        this.gameWon();
                    }
                }
            }

            gameWon() {
                this.gameState.gameWon = true;
                this.uiController.showVictory();
            }

            updateUI() {
                const progress = document.getElementById('questionProgress');
                const available = document.getElementById('availableQuestions');
                const level = document.getElementById('currentLevel');
                
                progress.textContent = `${this.gameState.answeredQuestions}/5`;
                available.textContent = `${this.gameState.questions.filter(q => !q.answered).length}/15`;
                
                // Update level based on progress
                if (this.gameState.answeredQuestions >= 4) {
                    this.gameState.level = 'Avanzado';
                } else if (this.gameState.answeredQuestions >= 2) {
                    this.gameState.level = 'Intermedio';
                } else {
                    this.gameState.level = 'B√°sico';
                }
                level.textContent = this.gameState.level;

                // Update progress indicators
                this.updateProgressIndicators();
            }

            updateProgressIndicators() {
                for (let lineNum = 1; lineNum <= 3; lineNum++) {
                    const container = document.getElementById(`line${lineNum}Progress`);
                    container.innerHTML = '';
                    
                    const lineQuestions = this.gameState.questions.filter(q => q.line === lineNum);
                    lineQuestions.forEach(q => {
                        const dot = document.createElement('div');
                        dot.className = `progress-dot ${q.answered ? 'completed' : ''}`;
                        container.appendChild(dot);
                    });
                }
            }

            render() {
                this.renderController.render();
            }

            startGameLoop() {
                const loop = () => {
                    this.updateGame();
                    this.render();
                    requestAnimationFrame(loop);
                };
                loop();
            }

            restartGame() {
                // Reset game state
                this.gameState = {
                    bat: {
                        x: 60,
                        y: 60,
                        size: 15,
                        speed: 3
                    },
                    echoWaves: [],
                    questions: [],
                    answeredQuestions: 0,
                    totalQuestions: 15,
                    requiredQuestions: 5,
                    currentQuestion: null,
                    gameWon: false,
                    level: 'B√°sico'
                };
                
                // Hide modals
                document.getElementById('victoryModal').style.display = 'none';
                document.getElementById('questionModal').style.display = 'none';
                
                // Reinitialize
                this.initializeQuestions();
                this.updateUI();
            }
        }

        // Input Controller - Handles all input methods
        class InputController {
            constructor(gameController) {
                this.game = gameController;
                this.keys = {};
                this.mobileControls = {
                    up: false,
                    down: false,
                    left: false,
                    right: false
                };
                
                this.motionControls = {
                    enabled: false,
                    sensitivity: 2.5,
                    tiltX: 0,
                    tiltY: 0,
                    calibrated: false,
                    calibrationX: 0,
                    calibrationY: 0
                };

                this.setupMobileControls();
            }

            handleKeyDown(e) {
                this.keys[e.key] = true;
            }

            handleKeyUp(e) {
                this.keys[e.key] = false;
            }

            setupMobileControls() {
                if (!this.isMobileDevice()) {
                    document.getElementById('controlStatus').textContent = 'üíª Controles de Teclado Activos';
                    return;
                }

                this.setupMotionControls();
                this.setupTouchControls();
            }

            isMobileDevice() {
                return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                       (window.DeviceOrientationEvent !== undefined);
            }

            setupMotionControls() {
                const enableBtn = document.getElementById('enableMotionBtn');
                const toggleBtn = document.getElementById('toggleControlMode');
                const controlStatus = document.getElementById('controlStatus');
                const tiltDisplay = document.getElementById('tiltDisplay');

                if (window.DeviceOrientationEvent) {
                    if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                        enableBtn.style.display = 'block';
                        enableBtn.onclick = async () => {
                            try {
                                const permission = await DeviceOrientationEvent.requestPermission();
                                if (permission === 'granted') {
                                    this.enableMotionControls();
                                } else {
                                    this.showTouchControls();
                                }
                            } catch (error) {
                                this.showTouchControls();
                            }
                        };
                    } else {
                        this.enableMotionControls();
                    }

                    toggleBtn.style.display = 'block';
                    toggleBtn.onclick = () => this.toggleControlMode();
                } else {
                    this.showTouchControls();
                }
            }

            enableMotionControls() {
                this.motionControls.enabled = true;
                document.getElementById('controlStatus').textContent = '‚úÖ Sensores de Movimiento Activos';
                document.getElementById('enableMotionBtn').style.display = 'none';
                document.getElementById('tiltDisplay').style.display = 'block';
                document.getElementById('toggleControlMode').textContent = 'Usar Controles T√°ctiles';

                window.addEventListener('deviceorientation', (e) => this.handleDeviceOrientation(e));

                setTimeout(() => {
                    if (!this.motionControls.calibrated) {
                        this.motionControls.calibrationX = this.motionControls.tiltX;
                        this.motionControls.calibrationY = this.motionControls.tiltY;
                        this.motionControls.calibrated = true;
                        document.getElementById('controlStatus').textContent = 'üéØ Controles Calibrados';
                    }
                }, 2000);
            }

            handleDeviceOrientation(event) {
                const beta = event.beta;
                const gamma = event.gamma;

                if (beta !== null && gamma !== null) {
                    this.motionControls.tiltX = gamma;
                    this.motionControls.tiltY = beta;

                    document.getElementById('tiltX').textContent = Math.round(gamma);
                    document.getElementById('tiltY').textContent = Math.round(beta);
                }
            }

            setupTouchControls() {
                const controlButtons = document.querySelectorAll('.control-button[data-direction]');
                
                controlButtons.forEach(button => {
                    const direction = button.getAttribute('data-direction');
                    
                    button.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        this.mobileControls[direction] = true;
                        button.style.background = 'linear-gradient(135deg, var(--accent-light), var(--accent-blue))';
                    });
                    
                    button.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        this.mobileControls[direction] = false;
                        button.style.background = 'linear-gradient(135deg, var(--accent-blue), var(--accent-light))';
                    });

                    button.addEventListener('mousedown', (e) => {
                        e.preventDefault();
                        this.mobileControls[direction] = true;
                    });
                    
                    button.addEventListener('mouseup', (e) => {
                        e.preventDefault();
                        this.mobileControls[direction] = false;
                    });
                });
            }

            showTouchControls() {
                document.getElementById('touchControlPad').style.display = 'grid';
                document.getElementById('toggleControlMode').textContent = 'Usar Sensores de Movimiento';
                document.getElementById('controlStatus').textContent = 'üëÜ Controles T√°ctiles Activos';
            }

            toggleControlMode() {
                if (this.motionControls.enabled) {
                    this.motionControls.enabled = false;
                    window.removeEventListener('deviceorientation', this.handleDeviceOrientation);
                    this.showTouchControls();
                    document.getElementById('tiltDisplay').style.display = 'none';
                } else {
                    document.getElementById('touchControlPad').style.display = 'none';
                    if (window.DeviceOrientationEvent) {
                        this.enableMotionControls();
                    }
                }
            }

            updateMovement() {
                const bat = this.game.gameState.bat;
                
                // Keyboard controls
                if (this.keys['ArrowUp'] || this.mobileControls.up) {
                    const newY = bat.y - bat.speed;
                    if (this.game.canMoveTo(bat.x, newY)) {
                        bat.y = newY;
                    }
                }
                if (this.keys['ArrowDown'] || this.mobileControls.down) {
                    const newY = bat.y + bat.speed;
                    if (this.game.canMoveTo(bat.x, newY)) {
                        bat.y = newY;
                    }
                }
                if (this.keys['ArrowLeft'] || this.mobileControls.left) {
                    const newX = bat.x - bat.speed;
                    if (this.game.canMoveTo(newX, bat.y)) {
                        bat.x = newX;
                    }
                }
                if (this.keys['ArrowRight'] || this.mobileControls.right) {
                    const newX = bat.x + bat.speed;
                    if (this.game.canMoveTo(newX, bat.y)) {
                        bat.x = newX;
                    }
                }

                // Motion controls
                if (this.motionControls.enabled && this.motionControls.calibrated) {
                    const threshold = 8;
                    const deltaX = this.motionControls.tiltX - this.motionControls.calibrationX;
                    const deltaY = this.motionControls.tiltY - this.motionControls.calibrationY;
                    
                    if (Math.abs(deltaX) > threshold) {
                        const newX = bat.x + (deltaX / 10) * this.motionControls.sensitivity;
                        if (this.game.canMoveTo(newX, bat.y)) {
                            bat.x = newX;
                        }
                    }
                    
                    if (Math.abs(deltaY) > threshold) {
                        const newY = bat.y + (deltaY / 10) * this.motionControls.sensitivity;
                        if (this.game.canMoveTo(bat.x, newY)) {
                            bat.y = newY;
                        }
                    }
                }
            }
        }

        // Render Controller - Handles all rendering
        class RenderController {
            constructor(gameController) {
                this.game = gameController;
                this.ctx = gameController.ctx;
                this.canvas = gameController.canvas;
            }

            render() {
                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Render game elements
                this.renderMaze();
                this.renderEchoWaves();
                this.renderQuestions();
                this.renderExit();
                this.renderBat();
            }

            renderMaze() {
                // Main maze walls
                this.ctx.fillStyle = '#333333';
                for (let y = 0; y < this.game.ROWS; y++) {
                    for (let x = 0; x < this.game.COLS; x++) {
                        if (this.game.maze[y] && this.game.maze[y][x] === 1) {
                            this.ctx.fillRect(
                                x * this.game.CELL_SIZE, 
                                y * this.game.CELL_SIZE, 
                                this.game.CELL_SIZE, 
                                this.game.CELL_SIZE
                            );
                        }
                    }
                }
                
                // Section dividers
                this.ctx.strokeStyle = '#555555';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([5, 5]);
                
                const dividerLines = [3, 7, 11];
                dividerLines.forEach(row => {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, row * this.game.CELL_SIZE);
                    this.ctx.lineTo(this.canvas.width, row * this.game.CELL_SIZE);
                    this.ctx.stroke();
                });
                
                this.ctx.setLineDash([]);
            }

            renderEchoWaves() {
                this.game.gameState.echoWaves.forEach(wave => {
                    this.ctx.beginPath();
                    this.ctx.arc(wave.x, wave.y, wave.radius, 0, Math.PI * 2);
                    this.ctx.strokeStyle = `rgba(255, 215, 0, ${wave.opacity * 0.8})`;
                    this.ctx.lineWidth = 3;
                    this.ctx.stroke();
                    
                    // Inner glow effect
                    this.ctx.beginPath();
                    this.ctx.arc(wave.x, wave.y, wave.radius - 2, 0, Math.PI * 2);
                    this.ctx.strokeStyle = `rgba(255, 255, 255, ${wave.opacity * 0.4})`;
                    this.ctx.lineWidth = 1;
                    this.ctx.stroke();
                });
            }

            renderBat() {
                const bat = this.game.gameState.bat;
                
                // Shadow
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                this.ctx.beginPath();
                this.ctx.ellipse(bat.x, bat.y + 5, bat.size + 2, 4, 0, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Main body with gradient
                const gradient = this.ctx.createRadialGradient(bat.x, bat.y, 0, bat.x, bat.y, bat.size);
                gradient.addColorStop(0, '#FFD700');
                gradient.addColorStop(0.7, '#FFA500');
                gradient.addColorStop(1, '#FF8C00');
                
                this.ctx.fillStyle = gradient;
                this.ctx.beginPath();
                this.ctx.arc(bat.x, bat.y, bat.size, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Wings with animation effect
                const wingOffset = Math.sin(Date.now() * 0.01) * 2;
                
                this.ctx.fillStyle = '#FF6347';
                // Left wing
                this.ctx.beginPath();
                this.ctx.ellipse(bat.x - 12, bat.y - 5 + wingOffset, 10, 6, -0.3, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Right wing
                this.ctx.beginPath();
                this.ctx.ellipse(bat.x + 12, bat.y - 5 + wingOffset, 10, 6, 0.3, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Eyes
                this.ctx.fillStyle = '#000000';
                this.ctx.beginPath();
                this.ctx.arc(bat.x - 5, bat.y - 3, 2, 0, Math.PI * 2);
                this.ctx.fill();
                
                this.ctx.beginPath();
                this.ctx.arc(bat.x + 5, bat.y - 3, 2, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Eye shine
                this.ctx.fillStyle = '#FFFFFF';
                this.ctx.beginPath();
                this.ctx.arc(bat.x - 4, bat.y - 4, 1, 0, Math.PI * 2);
                this.ctx.fill();
                
                this.ctx.beginPath();
                this.ctx.arc(bat.x + 6, bat.y - 4, 1, 0, Math.PI * 2);
                this.ctx.fill();
            }

            renderQuestions() {
                this.game.gameState.questions.forEach(q => {
                    if (!q.answered) {
                        // Question colors by line
                        const colors = {
                            1: { main: '#FF6B6B', glow: 'rgba(255, 107, 107, 0.4)' },
                            2: { main: '#FF4757', glow: 'rgba(255, 71, 87, 0.4)' },
                            3: { main: '#FF3838', glow: 'rgba(255, 56, 56, 0.4)' }
                        };
                        
                        const color = colors[q.line];
                        
                        // Glow effect
                        this.ctx.shadowColor = color.glow;
                        this.ctx.shadowBlur = 20;
                        
                        // Main circle
                        this.ctx.fillStyle = color.main;
                        this.ctx.beginPath();
                        this.ctx.arc(q.x, q.y, 15, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                        // Reset shadow
                        this.ctx.shadowBlur = 0;
                        
                        // Question mark
                        this.ctx.fillStyle = 'white';
                        this.ctx.font = 'bold 16px Arial';
                        this.ctx.textAlign = 'center';
                        this.ctx.fillText('?', q.x, q.y + 5);
                        
                        // Line indicator
                        this.ctx.fillStyle = '#FFD700';
                        this.ctx.font = 'bold 10px Arial';
                        this.ctx.fillText(q.line.toString(), q.x, q.y - 25);
                        
                        // Pulsing effect
                        const pulse = Math.sin(Date.now() * 0.005) * 0.1 + 0.9;
                        this.ctx.globalAlpha = pulse;
                        this.ctx.strokeStyle = 'white';
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.arc(q.x, q.y, 18, 0, Math.PI * 2);
                        this.ctx.stroke();
                        this.ctx.globalAlpha = 1;
                    }
                });
            }

            renderExit() {
                const exit = this.game.gameState.exit;
                const isAccessible = this.game.gameState.answeredQuestions >= this.game.gameState.requiredQuestions;
                
                // Exit glow
                if (isAccessible) {
                    this.ctx.shadowColor = 'rgba(46, 213, 115, 0.6)';
                    this.ctx.shadowBlur = 30;
                } else {
                    this.ctx.shadowColor = 'rgba(164, 176, 190, 0.3)';
                    this.ctx.shadowBlur = 15;
                }
                
                // Main exit circle
                this.ctx.fillStyle = isAccessible ? '#2ED573' : '#A4B0BE';
                this.ctx.beginPath();
                this.ctx.arc(exit.x, exit.y, 25, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Reset shadow
                this.ctx.shadowBlur = 0;
                
                // Border
                this.ctx.strokeStyle = '#FFD700';
                this.ctx.lineWidth = 3;
                this.ctx.stroke();
                
                // Flag icon
                this.ctx.fillStyle = 'white';
                this.ctx.font = 'bold 24px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('üèÅ', exit.x, exit.y + 8);
                
                // "SALIDA" text
                this.ctx.fillStyle = '#FFD700';
                this.ctx.font = 'bold 12px Arial';
                this.ctx.fillText('SALIDA', exit.x, exit.y - 35);
                
                // Progress indicator
                if (!isAccessible) {
                    this.ctx.fillStyle = '#FF4757';
                    this.ctx.font = 'bold 10px Arial';
                    const needed = this.game.gameState.requiredQuestions - this.game.gameState.answeredQuestions;
                    this.ctx.fillText(`Necesitas ${needed} m√°s`, exit.x, exit.y + 45);
                }
                
                // Rotating effect when accessible
                if (isAccessible) {
                    const rotation = Date.now() * 0.002;
                    this.ctx.save();
                    this.ctx.translate(exit.x, exit.y);
                    this.ctx.rotate(rotation);
                    this.ctx.strokeStyle = '#FFD700';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, 35, 0, Math.PI * 2);
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                    this.ctx.restore();
                }
            }
        }

        // UI Controller - Handles modals and interface
        class UIController {
            constructor(gameController) {
                this.game = gameController;
                this.setupEventListeners();
            }

            setupEventListeners() {
                // Close modal when clicking outside
                document.addEventListener('click', (e) => {
                    if (e.target.classList.contains('modal')) {
                        e.target.style.display = 'none';
                    }
                });
            }

            showQuestion(questionObj) {
                this.game.gameState.currentQuestion = questionObj;
                const q = questionObj.questionData;
                
                document.getElementById('questionText').textContent = q.question;
                
                const container = document.getElementById('answerContainer');
                container.innerHTML = '';
                
                q.answers.forEach((answer, index) => {
                    const button = document.createElement('button');
                    button.className = 'answer-button';
                    button.textContent = `${String.fromCharCode(65 + index)}. ${answer}`;
                    button.onclick = () => this.checkAnswer(index);
                    button.setAttribute('aria-label', `Opci√≥n ${String.fromCharCode(65 + index)}: ${answer}`);
                    container.appendChild(button);
                });
                
                document.getElementById('feedback').textContent = '';
                document.getElementById('questionModal').style.display = 'flex';
            }

            checkAnswer(selectedIndex) {
                const q = this.game.gameState.currentQuestion.questionData;
                const feedbackDiv = document.getElementById('feedback');
                
                if (selectedIndex === q.correct) {
                    feedbackDiv.textContent = `‚úÖ ¬°Correcto! ${q.explanation}`;
                    feedbackDiv.className = 'feedback correct';
                    
                    this.game.gameState.currentQuestion.answered = true;
                    this.game.gameState.answeredQuestions++;
                    this.game.updateUI();
                    
                    // Success sound effect (if audio is enabled)
                    this.playSuccessEffect();
                    
                    setTimeout(() => {
                        document.getElementById('questionModal').style.display = 'none';
                    }, 3500);
                } else {
                    feedbackDiv.textContent = `‚ùå Incorrecto. ${q.explanation}`;
                    feedbackDiv.className = 'feedback incorrect';
                    
                    // Move bat back slightly
                    setTimeout(() => {
                        const bat = this.game.gameState.bat;
                        const newX = Math.max(60, bat.x - 40);
                        const newY = Math.max(60, bat.y - 40);
                        
                        if (this.game.canMoveTo(newX, newY)) {
                            bat.x = newX;
                            bat.y = newY;
                        }
                        
                        document.getElementById('questionModal').style.display = 'none';
                    }, 3500);
                }
            }

            playSuccessEffect() {
                // Create a simple visual success effect
                const canvas = this.game.canvas;
                const rect = canvas.getBoundingClientRect();
                
                // Create temporary success particles
                for (let i = 0; i < 5; i++) {
                    setTimeout(() => {
                        this.createSuccessParticle();
                    }, i * 100);
                }
            }

            createSuccessParticle() {
                this.game.gameState.echoWaves.push({
                    x: this.game.gameState.bat.x + (Math.random() - 0.5) * 40,
                    y: this.game.gameState.bat.y + (Math.random() - 0.5) * 40,
                    radius: 0,
                    maxRadius: 30,
                    opacity: 1
                });
            }

            showVictory() {
                const modal = document.getElementById('victoryModal');
                modal.style.display = 'flex';
                
                // Add celebration effect
                this.createCelebrationEffect();
            }

            createCelebrationEffect() {
                // Create multiple celebration particles
                for (let i = 0; i < 10; i++) {
                    setTimeout(() => {
                        this.game.gameState.echoWaves.push({
                            x: Math.random() * this.game.canvas.width,
                            y: Math.random() * this.game.canvas.height,
                            radius: 0,
                            maxRadius: 50 + Math.random() * 50,
                            opacity: 1
                        });
                    }, i * 200);
                }
            }
        }

        // Performance optimizations
        class PerformanceManager {
            constructor() {
                this.frameCount = 0;
                this.lastFPSUpdate = 0;
                this.fps = 60;
            }

            updateFPS() {
                this.frameCount++;
                const now = performance.now();
                
                if (now - this.lastFPSUpdate >= 1000) {
                    this.fps = this.frameCount;
                    this.frameCount = 0;
                    this.lastFPSUpdate = now;
                }
            }

            optimizeCanvas(canvas) {
                // Set canvas size for better performance on high DPI displays
                const rect = canvas.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                
                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;
                
                const ctx = canvas.getContext('2d');
                ctx.scale(dpr, dpr);
                
                canvas.style.width = rect.width + 'px';
                canvas.style.height = rect.height + 'px';
            }
        }

        // Initialize game when page loads
        document.addEventListener('DOMContentLoaded', () => {
            // Add mobile controls visibility
            const mobileControls = document.getElementById('mobileControls');
            if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
                mobileControls.style.display = 'flex';
            }

            // Initialize performance manager
            const performanceManager = new PerformanceManager();
            
            // Initialize game controller
            window.gameController = new GameController();
            
            // Optimize canvas for high DPI displays
            // performanceManager.optimizeCanvas(window.gameController.canvas);
            
            // Add resize handler
            window.addEventListener('resize', () => {
                // Optionally handle canvas resizing here
            });
            
            // Add visibility change handler to pause game when tab is not active
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    // Game automatically pauses when tab is not visible due to requestAnimationFrame
                } else {
                    // Game resumes automatically
                }
            });
        });

        // Accessibility improvements
        document.addEventListener('keydown', (e) => {
            // Allow escape key to close modals
            if (e.key === 'Escape') {
                const openModal = document.querySelector('.modal[style*="flex"]');
                if (openModal && openModal.id !== 'victoryModal') {
                    openModal.style.display = 'none';
                }
            }
        });

        // Add focus management for accessibility
        const focusableElements = 'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])';

        function trapFocus(element) {
            const focusable = element.querySelectorAll(focusableElements);
            const firstFocusable = focusable[0];
            const lastFocusable = focusable[focusable.length - 1];

            element.addEventListener('keydown', (e) => {
                if (e.key === 'Tab') {
                    if (e.shiftKey) {
                        if (document.activeElement === firstFocusable) {
                            e.preventDefault();
                            lastFocusable.focus();
                        }
                    } else {
                        if (document.activeElement === lastFocusable) {
                            e.preventDefault();
                            firstFocusable.focus();
                        }
                    }
                }
            });
        }

        // Apply focus trap to modals
        document.querySelectorAll('.modal').forEach(modal => {
            trapFocus(modal);
        });
    </script>
</body>
</html>